ğŸ“‹ Veintree â€“ FonctionnalitÃ©s nÃ©cessaires
1. Fondations techniques

Programme Solana (Rust/Anchor)

Instruction register_proof: Ã©crire une preuve dâ€™identitÃ© (hash) on-chain

Instruction verify_proof: vÃ©rifier lâ€™existence/intÃ©gritÃ© dâ€™une preuve

Gestion basique de comptes dâ€™Ã©tat (hash de preuve + mÃ©tadonnÃ©es)

Support multi-utilisateurs (PDAs par user)

SDK (Rust & TypeScript)

Fonctions de hash â†’ toProofHash(input)

Fonctions pour construire/encoder les transactions

Wrappers simples pour register_proof et verify_proof

App (Next.js)

Page â€œLogin/Proofâ€ : bouton â†’ envoie une preuve

Page â€œVerifyâ€ : check que la preuve est bien enregistrÃ©e

Demo bilingue (FR/EN)

2. Authentification biomÃ©trique (mock pour hackathon)

Simulation dâ€™un scan de veines (image â†’ hash alÃ©atoire ou dÃ©terministe)

DÃ©tection de liveness simplifiÃ©e (ex. timestamp + random challenge)

Encapsulation du rÃ©sultat en preuve cryptographique

3. SÃ©curitÃ© et cryptographie

Hashing fort (SHA3/Blake2 ou Ã©quivalent Solana-friendly)

Signatures ECDSA/Ed25519 (natives Solana)

Mock dâ€™extension post-quantum (documentÃ©e, pas encore implÃ©mentÃ©e)

VÃ©rification que aucune donnÃ©e biomÃ©trique brute nâ€™est stockÃ©e â†’ seulement un hash + preuve

4. IntÃ©gration blockchain

DÃ©ploiement sur localnet et devnet

Scripts dâ€™initialisation des comptes (wallet, airdrop)

Test end-to-end :

User â†’ SDK â†’ Hash preuve

Transaction â†’ Programme Solana â†’ Ã‰criture on-chain

VÃ©rification on-chain

5. ExpÃ©rience utilisateur

Interface simple :

â€œEnregistrer une preuveâ€ (simulateur biomÃ©trique)

â€œVÃ©rifier une preuveâ€ (statut on-chain)

Messages bilingues FR/EN

IntÃ©gration dâ€™un QR code ou dâ€™une clÃ© partagÃ©e pour usage cross-device

6. Roadmap post-hackathon

Ajout dâ€™un dongle FPGA rÃ©el (interface hardware)

ImplÃ©mentation de preuve de liveness avancÃ©e

IntÃ©gration Zero-Knowledge Proofs (ex. zk-SNARK sur Solana)

Cas dâ€™usage rÃ©gulÃ©s : EUDI Wallet, santÃ©, essais cliniques
